#!/usr/bin/env python
import os
import uuid
import argparse
import logging
import requests
import json
import s3fs
from raster2stac import Raster2STAC

UUID = str(uuid.uuid4())
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
STAC_API_URL = "https://stac.intertwin.fedcloud.eu/collections/"


logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[logging.StreamHandler()]
)

logging.getLogger().setLevel(logging.DEBUG)
numba_logger = logging.getLogger('numba')
numba_logger.setLevel(logging.WARNING)

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

if not AWS_ACCESS_KEY_ID or not AWS_SECRET_ACCESS_KEY:
    raise ValueError("AWS_ACCESS_KEY and AWS_SECRET_KEY environment variables must be set")
else:
    logger.info("AWS_ACCESS_KEY and AWS_SECRET_KEY environment variables are set")
    logger.info(f"AWS_ACCESS_KEY: {AWS_ACCESS_KEY_ID}")
    logger.info(f"AWS_SECRET_KEY: {AWS_SECRET_ACCESS_KEY}")

parser = argparse.ArgumentParser()
parser.add_argument('--staticmaps_path', help='Static maps from HydroMT')
parser.add_argument('--forcings_path', help='Forcings from HydroMT')
parser.add_argument('--output_nc_path', help='Path to the output NetCDF file')
parser.add_argument('--output_dir', help='Output folder for the STAC Collection')


def main(*args) -> None:

    try:
        args = parser.parse_args()
    except Exception as e:
        logger.error(f"Error parsing arguments: {e}")
        return
    
    logger.info(f"Arguments: {args}")
    
    staticmaps_path = args.staticmaps_path
    
    forcings_path = args.forcings_path

    output_dir = args.output_dir

    output_nc = args.output_nc_path

    os.makedirs(output_dir, exist_ok=True)

    logger.info(f"staticmaps_path: {staticmaps_path}")
    logger.info(f"forcings_path: {forcings_path}")
    logger.info(f"output_nc: {output_nc}")
    logger.info(f"output_dir: {output_dir}")


    r2s = Raster2STAC(
        data = [[f"{staticmaps_path}"],[f"{forcings_path}"],[f"{output_nc}"]], 
        collection_id = f"{uuid.uuid4()}_WFLOW_OUTPUT", 
        collection_url = "https://stac.intertwin.fedcloud.eu/collections/",
        output_folder= output_dir,
        description="Collection containing the forcings.nc and staticmaps.nc files generated by HydroMT, necessary to run WFLOW.",
        title="Wflow output collection",
        ignore_warns=False,
        keywords=['intertwin', 'climate'],
        links= [{
            "rel": "license",
            "href": "https://cds.climate.copernicus.eu/api/v2/terms/static/licence-to-use-copernicus-products.pdf",
            "title": "License to use Copernicus Products",
        },
        ],
        providers=[
            {
                "url": "https://cds.climate.copernicus.eu/cdsapp#!/dataset/10.24381/cds.622a565a",
                "name": "Copernicus",
                "roles": [
                    "producer"
                ]
            },
            {
                "url": "https://cds.climate.copernicus.eu/cdsapp#!/dataset/10.24381/cds.622a565a",
                "name": "Copernicus",
                "roles": [
                    "licensor"
                ]
            },
            {
                "url": "http://www.eurac.edu",
                "name": "Eurac Research - Institute for Earth Observation",
                "roles": [
                    "host"
                ]
            }
        ],
        stac_version="1.0.0",
        s3_upload=True,
        s3_endpoint_url="https://objectstore.eodc.eu:2222",
        bucket_file_prefix = f"interTwin_EURAC/hydroform/wflow/{UUID}_",
        bucket_name = "rucio",
        aws_access_key = AWS_ACCESS_KEY_ID,
        aws_secret_key = AWS_SECRET_ACCESS_KEY,
        version=None,
        license="proprietary",
        write_collection_assets=True
    )

    r2s.generate_zarr_stac()

    with open(f"{output_dir}/{r2s.collection_id}.json","r") as f:
        stac_collection_to_post = json.load(f)
        requests.post(r2s.collection_url,json=stac_collection_to_post)
        stac_items = []
        with open(f"{output_dir}/inline_items.csv","r") as f:
            stac_items = f.readlines()
            for it in stac_items:
                stac_data_to_post = json.loads(it)
                requests.post(f"{STAC_API_URL}/{r2s.collection_id}/items",json=stac_data_to_post)

if __name__ == '__main__':
    main()

